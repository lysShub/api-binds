package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"

	"github.com/pkg/errors"
)

// merge 合并多个源文件为一个
func merge(files []io.Reader, pkgname string) (code string, err error) {
	var set = token.NewFileSet()
	var fs []*ast.File

	for _, f := range files {
		if f, err := parser.ParseFile(set, "", f, parser.AllErrors); err != nil {
			return "", errors.WithStack(err)
		} else {
			fs = append(fs, f)
		}
	}

	var f = &ast.File{
		Doc: &ast.CommentGroup{List: []*ast.Comment{
			{Text: "// Code generated by github.com/lysShub/binds; DO NOT EDIT."},
		}},
		Name:  ast.NewIdent(pkgname),
		Decls: []ast.Decl{nil},
	}

	var imps = map[imp]bool{}
	for _, e := range fs {
		for _, decl := range e.Decls {
			switch decl := decl.(type) {
			case *ast.GenDecl:
				if decl.Tok == token.IMPORT {
					for _, s := range decl.Specs {
						s := s.(*ast.ImportSpec)
						if s.Name != nil {
							imps[imp{
								name: s.Name.Name,
								path: s.Path.Value,
							}] = true
						} else {
							imps[imp{path: s.Path.Value}] = true
						}
					}
					continue
				}
			default:
			}
			f.Decls = append(f.Decls, decl)
		}
	}
	i := &ast.GenDecl{Tok: token.IMPORT}
	for p := range imps {
		s := &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: p.path,
			},
		}
		if p.name != "}" {
			s.Name = ast.NewIdent(p.name)
		}
		i.Specs = append(i.Specs, s)
	}
	f.Decls[0] = i

	var b = &bytes.Buffer{}
	if err := format.Node(b, set, f); err != nil {
		return "", errors.WithStack(err)
	}
	return b.String(), nil

}

type imp struct {
	path string
	name string
}
