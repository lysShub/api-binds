package binds

import (
	"fmt"
	"go/format"
	"os"

	"github.com/pkg/errors"
)

type builder struct {
	// 公共import包
	imports []string
	// 错误日志、直接可以取用ctx(*gin.Context), err(error), 如
	//  slog.LogAttrs(context.Background(), slog.LevelError, err.Error(), slog.String("uri", ctx.Request.RequestURI))
	logerr string
	// 原始类型名, 不包含包名
	name string

	files map[string]*file
}

func (b *builder) Build() (err error) {
	for _, f := range b.files {
		if len(f.imports) > 0 {
			for _, e := range b.imports {
				f.imports[e] = true
			}
		}
	}

	for _, f := range b.files {
		if err := f.build(b.name, b.logerr); err != nil {
			return nil
		}
	}
	return nil
}

func (b *builder) file(name string) *file {
	if b.files == nil {
		b.files = map[string]*file{}
	}

	f, has := b.files[name]
	if !has {
		f = &file{filename: name, imports: map[string]bool{}}
		b.files[name] = f
	}
	return f
}

type file struct {
	filename string          // 文件名, 不带后缀
	imports  map[string]bool // 生成文件import
	methods  []method        // 类型拥有的方法
	typedef  bool            // 是否在此文件定义Handler

	writer
}

type method struct {
	httpmethod string // http请求类型, "GET", "POST"
	originName string // 原始函数名
	name       string // 函数名
	req        string // req 参数类型的字面量
	resp       string // resp 参数指针解引用类型的字面量
}

func (f *file) build(name, logger string) error {
	var (
		genname = string(touper(name[0])) + name[1:]
		key     = string(name[0]) + "."
		prefix  = fmt.Sprintf("func (%s *%s)", string(name[0]), genname)
	)

	_, pkgname, err := pkginfo(nil)
	if err != nil {
		return err
	}
	f.Str(fmt.Sprintf(`// Code generated by "%s", from %s; DO NOT EDIT.`, cmd, vcs)).NL()
	f.Str("package ").Str(pkgname).NL()

	f.Str("import (").NL()
	for imp := range f.imports {
		f.Str(imp).NL()
	}
	f.Char(')').NL()

	if f.typedef {
		f.Str("type ").Str(genname).Str(" struct{").NL().
			Str("*").Str(name).NL()
		f.Str("}").NL()
	}

	for _, m := range f.methods {
		f.Str(prefix).Str(m.name).Str("(ctx *gin.Context){").NL()
		f.Str("var req ").Str(m.req).NL()
		f.Str("var resp ").Str(m.resp).NL()
		f.NL()

		switch m.httpmethod {
		case "GET":
			f.Str("var err = ctx.BindQuery(&req)").NL()
		case "POST":
			f.Str("var err = ctx.Bind(&req)").NL()
		default:
			return errors.Errorf("not support http method %s", m.httpmethod)
		}
		f.buildHandleErr(logger)
		f.NL()

		f.Str("code,err := ").Str(key).Str(m.originName).Str("(req, &resp)").NL()
		f.buildHandleErr(logger)
		f.Str("ctx.JSON(code, resp)").NL()
		f.Str("}").NL()
		f.NL()
	}

	return create(f.filename, f.Bytes())
}

func (f *file) buildHandleErr(logger string) {
	f.Str("if err != nil {").NL()
	f.Str("ctx.Status(http.StatusBadRequest)").NL()

	if logger != "" {
		f.Str(logger).NL()
	}

	f.Str("return").NL()
	f.Str("}").NL()
}

func create(filename string, code []byte) error {
	if fb, err := format.Source(code); err != nil {
		return err
	} else {
		fh, err := os.Create(fmt.Sprintf("%s_gen.go", filename))
		if err != nil {
			return errors.WithStack(err)
		}
		defer fh.Close()
		if _, err := fh.Write(fb); err != nil {
			return nil
		}
	}
	return nil
}
