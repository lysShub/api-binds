package binds

import (
	"fmt"
	"go/format"
	"os"
	"path"
	"reflect"
	"strconv"
	"strings"

	"github.com/pkg/errors"
)

type builder struct {
	// 错误日志、直接可以取用ctx(*gin.Context), err(error), 如
	//  slog.LogAttrs(context.Background(), slog.LevelError, err.Error(), slog.String("uri", ctx.Request.RequestURI))
	logerr string
	// 原始类型名, 不包含包名
	name string

	// 存储文件对象, key为文件名(没有后缀、没有_gen)
	files map[string]*file
}

func (b *builder) Build() (err error) {
	// 避免在
	// (h *handler)PostUser(xx)(int,error)
	// (h *handler)GetUser(xx)(int,error)
	// 情况下生成重复方法
	var names = map[string]int{}
	for _, f := range b.files {
		for _, e := range f.methods {
			names[e.name] += 1
		}
	}
	for _, f := range b.files {
		for i, e := range f.methods {
			if names[e.name] > 1 {
				f.methods[i].name = fmt.Sprintf("%s%s", e.name, e.httpmethod)
			}
		}
	}

	for _, f := range b.files {
		if err := f.build(b.name, b.logerr); err != nil {
			return err
		}
	}
	return nil
}

func (b *builder) file(name string) *file {
	if b.files == nil {
		b.files = map[string]*file{}
	}

	f, has := b.files[name]
	if !has {
		f = &file{filename: name, imports: map[string]bool{}}
		b.files[name] = f
	}
	return f
}

type file struct {
	filename string          // 文件名, 不带后缀
	imports  map[string]bool // 生成文件import

	// 命中的方法
	methods []method

	// 如果长度不为0, 则此文件定义Handler, 同时导出handler的其他函数
	others []reflect.Method

	writer
}

type method struct {
	httpmethod string // http请求类型, "GET", "POST"
	originName string // 原始函数名
	name       string // 函数名
	req        string // req 参数类型的字面量
	resp       string // resp 参数指针解引用类型的字面量
}

func (f *file) build(name, logger string) error {
	var (
		genname = string(touper(name[0])) + name[1:]
		key     = string(name[0]) + ".i."
		prefix  = fmt.Sprintf("func (%s *%s)", string(name[0]), genname)
	)

	_, pkgname, err := pkginfo(nil)
	if err != nil {
		return err
	}
	f.Str(fmt.Sprintf(`// Code generated by "%s", from %s; DO NOT EDIT.`, cmd, vcs)).NL()
	f.Str("package ").Str(pkgname).NL()

	f.Str("import (").NL()
	for imp := range f.imports {
		f.Str(imp).NL()
	}
	f.Char(')').NL()

	// handler的其他导出函数
	if len(f.others) > 0 {
		f.Str("type ").Str(genname).Str(" struct{").NL().
			Str("i *").Str(name).NL()
		f.Str("}").NL()

		for _, m := range f.others {
			var args []string
			var t = m.Type

			f.Str(prefix).Str(m.Name).Str("( ")
			for i := range t.NumIn() {
				if i > 0 {
					arg := fmt.Sprintf("arg%d", i)
					args = append(args, arg)
					f.Str(arg).SP().Str(t.In(i).String()).Str(",")
				}
			}
			f.Unchar().Str(") ")
			switch t.NumOut() {
			case 0:
			case 1:
				f.Str(t.Out(0).String())
			default:
				f.Str("(")
				for i := range t.NumOut() {
					f.Str("ret").Int(i).SP().Str(t.Out(i).String()).Str(",")
				}
				f.Unchar().Str(")")
			}
			f.Str("{ ")
			if t.NumOut() > 0 {
				f.Str("return ")
			}
			f.Str(key).Str(m.Name).Str("(").Str(strings.Join(args, ",")).Str(")")
			f.Str(" }")
			f.NL()
		}
	}

	for _, m := range f.methods {
		f.Str(prefix).Str(m.name).Str("(ctx *gin.Context){").NL()
		{
			f.Str("var req ").Str(m.req).NL()
			f.Str("var resp ").Str(m.resp).NL()
			f.NL()

			switch m.httpmethod {
			case "GET":
				f.Str("var err = ctx.BindQuery(&req)").NL()
			case "POST":
				f.Str("var err = ctx.Bind(&req)").NL()
			default:
				return errors.Errorf("not support http method %s", m.httpmethod)
			}
			f.buildHandleErr(logger)
			f.NL()

			f.Str("code,err := ").Str(key).Str(m.originName).Str("(req, &resp)").NL()
			f.buildHandleErr(logger)
			f.Unchar().Str(" else if code==0 { ").NL().
				Str("code=http.StatusOK").NL()
			f.Str("}").NL()

			f.Str("ctx.JSON(code, resp)").NL()
		}
		f.Str("}").NL()
		f.NL()
	}

	return create(f.filename, f.Bytes())
}

func (f *file) buildHandleErr(logger string) *file {
	f.Str("if err != nil {").NL()
	f.Str("ctx.Status(http.StatusBadRequest)").NL()

	if logger != "" {
		f.Str(logger).NL()
	}

	f.Str("return").NL()
	f.Str("}").NL()
	return f
}

func (f *file) collectMethodImports(m reflect.Method) error {
	self, _, err := pkginfo(nil)
	if err != nil {
		return err
	}

	t := m.Type
	for i := range t.NumIn() {
		pkgpath, pkgname, err := pkginfo(t.In(i))
		if err != nil {
			return err
		} else if pkgpath == "" || pkgpath == self {
			continue
		}

		imp := strconv.Quote(pkgpath)
		if path.Base(pkgpath) != pkgname {
			imp = fmt.Sprintf("%s %s", pkgname, imp) // 文件夹名与包名不同
		}
		f.imports[imp] = true
	}
	for i := range t.NumOut() {
		pkgpath, pkgname, err := pkginfo(t.Out(i))
		if err != nil {
			return err
		} else if pkgpath == "" || pkgpath == self {
			continue
		}

		imp := strconv.Quote(pkgpath)
		if path.Base(pkgpath) != pkgname {
			imp = fmt.Sprintf("%s %s", pkgname, imp) // 文件夹名与包名不同
		}
		f.imports[imp] = true
	}
	return nil
}

func create(filename string, code []byte) error {
	if fb, err := format.Source(code); err != nil {
		return err
	} else {
		fh, err := os.Create(fmt.Sprintf("%s_gen.go", filename))
		if err != nil {
			return errors.WithStack(err)
		}
		defer fh.Close()
		if _, err := fh.Write(fb); err != nil {
			return nil
		}
	}
	return nil
}
